var bluewhitered = "vec3 colormap(vec3 direction) {     if (direction.z < 0.0) {         vec3 color_down = vec3(0.0, 0., 1.0);         vec3 color_up = vec3(1.0, 1.0, 1.0);         return mix(color_down, color_up, normalize(direction).z+1.0);     } else {         vec3 color_down = vec3(1.0, 1.0, 1.0);         vec3 color_up = vec3(1.0, 0.0, 0.0);         return mix(color_down, color_up, normalize(direction).z);     } }";
let webglspins, iteration = 0,
    n = 0,
    simulateObject = {
        insertedFile: "",
        spinPositions: [],
        spinDirections: [],
        spinNeighbor: [],
        simulateNew: t => {
            n = t, simulateObject.spinPositions = [], simulateObject.spinDirections = [], webglspins = simulateObject.createwebglspins(), iteration += 1;
            for (var e = 0; e < Math.sqrt(n); e++)
                for (var i = 0; i < Math.sqrt(n); i++) {
                    var s = [2 * i, 2 * e, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, s);
                    var a = [Math.sin(.3 * i) * Math.cos(.05 * (e + iteration)), Math.cos(.3 * i) * Math.cos(.05 * (e + iteration)), Math.sin(.05 * (e + iteration))];
                    Array.prototype.push.apply(simulateObject.spinDirections, a)
                }
            webglspins.updateSpins(simulateObject.spinPositions, simulateObject.spinDirections), simulateObject.neighbors()
        },
        simulateByData: () => {
            n = simulateObject.spinPositions.length / 3, webglspins = simulateObject.createwebglspins(), webglspins.updateSpins(simulateObject.spinPositions, simulateObject.spinDirections), simulateObject.neighbors()
        },
        downloadFile: () => {
            const t = parseToFile(simulateObject.spinPositions, simulateObject.spinDirections);
            var e = new Blob(t, {
                type: "text/plain"
            });
            saveAs(e, "spins.mfsys")
        },
        createwebglspins: () => new WebGLSpins(document.getElementById("webgl-canvas"), {
            cameraLocation: [Math.sqrt(n) / 1.5, .95 * Math.sqrt(n), 2.5 * Math.sqrt(n)],
            centerLocation: [Math.sqrt(n) / 1.5, .95 * Math.sqrt(n), 0],
            upVector: [0, 1, 0],
            levelOfDetail: 5,
            backgroundColor: [.1, .11, .13],
            colormapImplementation: bluewhitered,
            renderers: [WebGLSpins.renderers.ARROWS, [WebGLSpins.renderers.SPHERE, [0, 0, .2, .2]],
                [WebGLSpins.renderers.COORDINATESYSTEM, [0, .2, .2, .2]],
            ]
        }),
        neighbors: () => {
            for (var t = 0; t < Math.sqrt(n); t++)
                for (var e = 0; e < Math.sqrt(n); e++) {
                    var i = 4 * (t * Math.sqrt(n) + e);
                    simulateObject.spinNeighbor[i] = simulateObject.border_check(t + 1) * Math.sqrt(n) + e, simulateObject.spinNeighbor[i + 1] = t * Math.sqrt(n) + simulateObject.border_check(e + 1), simulateObject.spinNeighbor[i + 2] = simulateObject.border_check(t - 1) * Math.sqrt(n) + e, simulateObject.spinNeighbor[i + 3] = t * Math.sqrt(n) + simulateObject.border_check(e - 1)
                }
        },
        magnetization() {
            var M_x = 0.;
            var M_y = 0.;
            var M_z = 0.;
            var M = 0.;
    
            for (var num = 0; num < n * 3; num += 3) {
                M_x += simulateObject.spinDirections[num]; // x
                M_y += simulateObject.spinDirections[num + 1]; // y
                M_z += simulateObject.spinDirections[num + 2]; // z
            }
            M = Math.sqrt(M_x * M_x + M_y * M_y + M_z * M_z) / (n);
            document.getElementById('display-magnetization').value = "M: " + Math.abs(M);
            M = Math.sqrt(M_x * M_x + M_y * M_y + M_z * M_z) / (n);
        },
        ferromagnetic_create() {
            simulateObject.spinPositions = [], simulateObject.spinDirections = [];
            for (var t = 0; t < Math.sqrt(n); t++)
                for (var e = 0; e < Math.sqrt(n); e++) {
                    var i = [2 * e, 2 * t, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, i);
                    Array.prototype.push.apply(simulateObject.spinDirections, [0, 0, 1])
                }
            webglspins.updateSpins(simulateObject.spinPositions, simulateObject.spinDirections), simulateObject.neighbors()
            this.energy();
            this.magnetization();
        },
        border_check: t => (Math.sqrt(n) + t) % Math.sqrt(n),
        espin(t) {
            var e = 0,
                i = 3 * t,
                s = 3 * t + 1,
                n = 3 * t + 2,
                a = 3 * simulateObject.spinNeighbor[4 * t],
                r = 3 * simulateObject.spinNeighbor[4 * t + 1],
                o = 3 * simulateObject.spinNeighbor[4 * t + 2],
                c = 3 * simulateObject.spinNeighbor[4 * t + 3];
            return e += simulateObject.spinDirections[i] * (simulateObject.spinDirections[a] + simulateObject.spinDirections[r] + simulateObject.spinDirections[o] + simulateObject.spinDirections[c]), e += simulateObject.spinDirections[s] * (simulateObject.spinDirections[a + 1] + simulateObject.spinDirections[r + 1] + simulateObject.spinDirections[o + 1] + simulateObject.spinDirections[c + 1]), -1 * (e += simulateObject.spinDirections[n] * (simulateObject.spinDirections[a + 2] + simulateObject.spinDirections[r + 2] + simulateObject.spinDirections[o + 2] + simulateObject.spinDirections[c + 2]))
        },
        energy() {
                       var Esys = 0.;
            for (var num = 0; num < n; ++num) {
                Esys += simulateObject.espin(num)
            }
            Esys /= 2. * n
            document.getElementById('display-energy').value = "E: " + Esys;
        },
        getRandomInclusive: (t, e) => (t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t),
        getRandomIzing: () => 0 === Math.floor(2 * Math.random()) ? -1 : 1,
        randomspinIzing_create() {
            iteration += 1, simulateObject.spinPositions = [], simulateObject.spinDirections = [];
            for (var t = 0; t < Math.sqrt(n); t++)
                for (var e = 0; e < Math.sqrt(n); e++) {
                    var i = simulateObject.getRandomIzing(),
                        s = [2 * e, 2 * t, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, s);
                    var a = [0, 0, i];
                    Array.prototype.push.apply(simulateObject.spinDirections, a)
                }
            webglspins.updateSpins(simulateObject.spinPositions, simulateObject.spinDirections);
            this.energy();
            this.magnetization();
        },
        randomspin_create() {
            Math.sqrt(n);
            simulateObject.spinPositions = [], simulateObject.spinDirections = [];
            for (var t = 0; t < Math.sqrt(n); t++)
                for (var e = 0; e < Math.sqrt(n); e++) {
                    var i = [2 * e, 2 * t, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, i);
                    var s = simulateObject.getRandomInclusive(0, 360),
                        a = simulateObject.getRandomInclusive(0, 180),
                        r = s * Math.PI / 180,
                        o = a * Math.PI / 180,
                        c = [Math.sin(o) * Math.cos(r), Math.sin(o) * Math.sin(r), Math.cos(o)];
                    Array.prototype.push.apply(simulateObject.spinDirections, c)
                }
            webglspins.updateSpins(simulateObject.spinPositions, simulateObject.spinDirections);
            this.energy();
            this.magnetization();
        },
        skyrmion_create() {
            var t = .125 * Math.sqrt(n);
            simulateObject.spinPositions = [], simulateObject.spinDirections = [];
            for (var e = 0; e < Math.sqrt(n); e++)
                for (var i = 0; i < Math.sqrt(n); i++) {
                    var s = [2 * i, 2 * e, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, s);
                    var a = i - Math.sqrt(n) / 2,
                        r = e - Math.sqrt(n) / 2,
                        o = a * a + r * r + t * t,
                        c = [-t * a / o, -t * r / o, (a * a + r * r - t * t) / o];
                    Array.prototype.push.apply(simulateObject.spinDirections, c)
                }
            webglspins.updateSpins(simulateObject.spinPositions, simulateObject.spinDirections);
            this.energy();
            this.magnetization();
        },
        default_camera() {
            webglspins.updateOptions({
                cameraLocation: [Math.sqrt(n) / 1.5, .95 * Math.sqrt(n), 2.5 * Math.sqrt(n)],
                centerLocation: [Math.sqrt(n) / 1.5, .95 * Math.sqrt(n), 0],
                upVector: [0, 1, 0]
            })
        },
        getSpinPosition(){
            return this.spinPositions;
        },
        getSpinDirection(){
            return this.spinDirections;
        },
    };

    function parseToFile(spinPositions, spinDirections) {
        const spinsStrings = [];
        for (let index = 0; index < spinPositions.length; index += 3) {
            let spinPosition = spinPositions.slice(index, index + 3);
            let spinDirection = spinDirections.slice(index, index + 3);
    
            let pos = spinPosition.map(el => `${el} \t`);
            let dir = spinDirection.map(el => `${el} \t`);
            let result = "";
            pos.forEach(p => result += p);
            dir.forEach(p => result += p);
            // чтобы в последней строке не добавлялся снос
            if (index != spinPositions.length - 3)
                result += "\n";
            spinsStrings.push(result);
        }
        return spinsStrings;
    }

function parseToArrays(t, e) {
    const i = t.split("\n");
    e.spinPositions = [], e.spinDirections = [];
    for (let t = 0; t < i.length; t += 1) {
        let s = i[t].split("\t"),
            n = s.slice(0, 3),
            a = s.slice(3, 6);
        for (let t = 0; t < 3; t++) {
            const i = parseFloat(n[t]),
                s = parseFloat(a[t]);
            e.spinPositions.push(i), e.spinDirections.push(s)
        }
    }
}

//Смена цвета
function updateColormap() {
    var colormap = $("option:selected", $('#select-colormap'))[0].value;
    webglspins.updateOptions({
    colormapImplementation: WebGLSpins.colormapImplementations[colormap]
    });
}

function updateRenderMode() {
    var renderMode = $("option:selected", $('#select-rendermode'))[0].value;
    var renderers = [WebGLSpins.renderers[renderMode]];
    var showCoordinateSystemWidget = true;
    if (showCoordinateSystemWidget) {
      renderers.push([WebGLSpins.renderers.COORDINATESYSTEM, [0, 0, 0.2, 0.2]]);
    }
    var showSphereWidget = true;
    if (showSphereWidget) {
      renderers.push([WebGLSpins.renderers.SPHERE, [0, 0, 0.2, 0.2]]);
    }
    webglspins.updateOptions({
      renderers: renderers
    });
  }

// Меню - бургер
function toggleMenu(){
    const button = document.getElementById('btn-menu');
    const menu = document.getElementById('list-menu');
    button.classList.toggle('active');
    menu.classList.toggle('active');
}

var flagRuller = 0;
var flagSwapSpin = 0;
var arrayForDistance = [];
var distance = 0;

function getDistance(){
    if(flagRuller == 2){
        document.getElementById('display-distance').value = calcDistance().toFixed(3);
        arrayForDistance = [];
        return;
    }
    document.getElementById('display-distance').value = "Точки не выбраны";
    flagRuller = 1;
}

function calcDistance(){
    console.log ("x: " + arrayForDistance[0] + "y: " + arrayForDistance[1] + "x: " + arrayForDistance[2] + "y: " + arrayForDistance[3]);
    return(Math.sqrt((arrayForDistance[0]-arrayForDistance[2])*(arrayForDistance[0]-arrayForDistance[2]) + 
    (arrayForDistance[1]-arrayForDistance[3])*(arrayForDistance[1]-arrayForDistance[3]) ));
}

function swapSpin(){
    if (flagSwapSpin == 0){
    flagSwapSpin = 1;
    }
    else if (flagSwapSpin == 1){
        flagSwapSpin = 0;
    }
}
var counter = 0;
function getXY(x,y){
    var temp = [];
    var n = 0;
    console.log("Я здесь был: " + counter );
    counter++;
    if (flagRuller == 1){
        arrayForDistance.push(x,y);
        flagRuller ++;
    }
    else if (flagRuller == 2){
        arrayForDistance.push(x,y);
        getDistance();
        flagRuller = 0;
    }
    if (flagSwapSpin){
        temp = simulateObject.getSpinDirection();
        console.log("spinDirection size:" + temp.length);
        n = document.getElementById("initN").value;
        var numb = (n*(y-1) + x)*3-3;
        console.log("Size of grid: " + n + " use ind: " + numb.toFixed(3));
        temp [(n*(y-1) + x)*3-3] *= -1;
        temp [(n*(y-1) + x)*3-2] *= -1;
        temp [(n*(y-1) + x)*3-1] *= -1;
        webglspins.updateSpins(simulateObject.getSpinPosition(), temp);
        simulateObject.energy();
        simulateObject.magnetization();
    }
    document.getElementById('display-xy').value = "X: " + x + " Y: " + y;
}

//x 12 y 17 x 9 y 4 