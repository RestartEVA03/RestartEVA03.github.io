var bluewhitered = "vec3 colormap(vec3 direction) {     if (direction.z < 0.0) {         vec3 color_down = vec3(0.0, 0., 1.0);         vec3 color_up = vec3(1.0, 1.0, 1.0);         return mix(color_down, color_up, normalize(direction).z+1.0);     } else {         vec3 color_down = vec3(1.0, 1.0, 1.0);         vec3 color_up = vec3(1.0, 0.0, 0.0);         return mix(color_down, color_up, normalize(direction).z);     } }";
let webglspins, iteration = 0, k;
    n = 0,
    simulateObject = {
        insertedFile: "",
        spinPositions: [],
        spinDirections: [],
        spinPositionsWeb: [],
        spinDirectionsWeb: [],
        spinNeighbor: [],
        simulateNew: (t,k) => {
            n = t, simulateObject.spinPositions = [], simulateObject.spinDirections = [], webglspins = simulateObject.createwebglspins(), iteration += 1;
            for (var e = 0; e < Math.sqrt(n); e++)
                for (var i = 0; i < Math.sqrt(n); i++) {
                    var s = [i * 5, e*5, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, s);
                    var a = [Math.sin(.3 * i) * Math.cos(.05 * (e + iteration)), Math.cos(.3 * i) * Math.cos(.05 * (e + iteration)), Math.sin(.05 * (e + iteration))];
                    Array.prototype.push.apply(simulateObject.spinDirections, a)
                }
            simulateObject.createDataForWebGL(k), simulateObject.neighbors(), simulateObject.updateCameraLocation();
        },
        //Генерация массива данных, для отображения спинов через WebGL
        createDataForWebGL: (k) => {
            simulateObject.spinDirectionsWeb = [];
            simulateObject.spinPositionsWeb = [];
            var oldPos = simulateObject.spinPositions;
            var oldDir = simulateObject.spinDirections;
            var minPos = simulateObject.findMinLengthPos();
            var minLength = simulateObject.findMinLengthSpin();
            var tempPos = [];
            var tempDir = [];
            for (var i = 0; i < oldDir.length; i+=3){
                tempPos[0] = oldPos[i] / minPos;
                tempPos[1] = oldPos[i+1] / minPos;
                tempPos[2] = oldPos[i+2];
                tempDir[0] = oldDir[i]/minLength * simulateObject.k;
                tempDir[1] = oldDir[i+1]/minLength * simulateObject.k;
                tempDir[2] = oldDir[i+2]/minLength * simulateObject.k;
                Array.prototype.push.apply(simulateObject.spinDirectionsWeb, tempDir);
                Array.prototype.push.apply(simulateObject.spinPositionsWeb, tempPos);
            }
            webglspins.updateSpins(simulateObject.spinPositionsWeb, simulateObject.spinDirectionsWeb)
        },
        //Возвращает длину вектора
        vectLength: (vect) => {
            var tmp = 0;
            var value = 0;
            for (var i = 0; i < 6; i+=2){
                    value = Math.abs(vect[i] - vect[i+1]);
                    tmp += value * value;
            }
            return Math.sqrt(tmp);
        },
        //Поиск минимального расстояния между позициями спинов
        findMinLengthPos: () => {
            var tempPos = simulateObject.spinPositions;
            minLength = simulateObject.vectLength([tempPos[0],tempPos[3],tempPos[1], tempPos[4], tempPos[2], tempPos[5]]);
            var length;
            for (var i = 3; i < tempPos.length - 3; i+=3)
                for (var j = i+3; j < tempPos.length - 3; j+=3){
                    length = simulateObject.vectLength([tempPos[i], tempPos[j], tempPos[i+1], tempPos[j+1], tempPos[i+2], tempPos[j+2]]);
                    if (minLength > length){
                        minLength = length;
                    }
                }
            return minLength;
        },
        //Поиск минимальной длины вектора
        findMinLengthSpin: () => {
            var pos = simulateObject.spinPositions;
            var dir = simulateObject.spinDirections;
            var length = [];
            for (var i = 0; i < dir.length; i+=3){
                length.push(Math.sqrt(Math.abs(((dir[i]-pos[i]) * (dir[i]-pos[i])) + ((dir[i+1]-pos[i+1]) * (dir[i+1]-pos[i+1])) + dir[i+2])));
            }
            var min = length[0];
            for (var i = 0; i < dir.length/3; i++){
                if (length[i] < min) {min = length[i];}
            }
            return min;
        },
        simulateByData: () => {
            n = simulateObject.spinPositions.length / 3, webglspins = simulateObject.createwebglspins(), simulateObject.createDataForWebGL(k), simulateObject.neighbors(), simulateObject.updateCameraLocation();
        },
        downloadFile: () => {
            const t = parseToFile(simulateObject.spinPositions, simulateObject.spinDirections);
            var e = new Blob(t, {
                type: "text/plain"
            });
            saveAs(e, "spins.mfsys")
        },
        createwebglspins: () => {
            if (flagCreator == 0) {
                return new WebGLSpins(document.getElementById('webgl-canvas'), {
                    upVector: [0, 1, 0],
                    levelOfDetail: 10,
                    backgroundColor: [0.1, 0.11, 0.13],
                    colormapImplementation: bluewhitered,
                    renderers: [
                        WebGLSpins.renderers.ARROWS, [WebGLSpins.renderers.SPHERE, [0.0, 0.0, 0.2, 0.2]],
                        [WebGLSpins.renderers.COORDINATESYSTEM, [0.0, 0.2, 0.2, 0.2]]
                    ]
                })
                flagCreator++;
            } else {
                webglspins.updateOptions();
                return webglspins;
            };
        },
        //Поиск максимальной значения координат X,Y
        findMaxXY: () => {
            var tempXY = simulateObject.spinPositionsWeb;
            var maxXY = [tempXY[0],tempXY[1]];
            for (var i = 0,  b = 1; i,b < tempXY.length; i+=3, b+=3){
                if (maxXY[0] < tempXY[i]){ maxXY[0] = tempXY[i] }
                if (maxXY[1] < tempXY[b]){ maxXY[1] = tempXY[b] }
            }
            return maxXY;
        },
        //Поиск минимального значения координат X,Y
        findMixXY: () => {
            var tempXY = simulateObject.spinPositionsWeb;
            var minXY = [tempXY[0],tempXY[1]];
            var s = 1;
            for (var i = 0,  b = 1; i,b < tempXY.length; i+=3, b+=3){
                if (minXY[0] > tempXY[i]){ minXY[0] = tempXY[i] }
                if (minXY[1] > tempXY[b]){ minXY[1] = tempXY[b] }
            }
            return minXY;
        },
        //Обновить положение камеры (установить на середину решетки)
        updateCameraLocation: () => {
            var maxXY = simulateObject.findMaxXY();
            var minXY = simulateObject.findMixXY();
            var l = (maxXY[0] + minXY[0]) / 2;
            var c = (maxXY[1] + minXY[1]) / 2;
            webglspins.updateOptions({
                cameraLocation: [l, c, Math.sqrt(n)*2],
                centerLocation: [ l,  c , 0],
            });
        },
        neighbors: () => {
            for (var t = 0; t < Math.sqrt(n); t++)
                for (var e = 0; e < Math.sqrt(n); e++) {
                    var i = 4 * (t * Math.sqrt(n) + e);
                    simulateObject.spinNeighbor[i] = simulateObject.border_check(t + 1) * Math.sqrt(n) + e, simulateObject.spinNeighbor[i + 1] = t * Math.sqrt(n) + simulateObject.border_check(e + 1), simulateObject.spinNeighbor[i + 2] = simulateObject.border_check(t - 1) * Math.sqrt(n) + e, simulateObject.spinNeighbor[i + 3] = t * Math.sqrt(n) + simulateObject.border_check(e - 1)
                }
        },
        magnetization() {
            var M_x = 0.;
            var M_y = 0.;
            var M_z = 0.;
            var M = 0.;
    
            for (var num = 0; num < n * 3; num += 3) {
                M_x += simulateObject.spinDirections[num]; // x
                M_y += simulateObject.spinDirections[num + 1]; // y
                M_z += simulateObject.spinDirections[num + 2]; // z
            }
            M = Math.sqrt(M_x * M_x + M_y * M_y + M_z * M_z) / (n);
            document.getElementById('display-magnetization').value = "M: " + Math.abs(M);
        },
        ferromagnetic_create() {
            simulateObject.spinPositions = [], simulateObject.spinDirections = [];
            for (var t = 0; t < Math.sqrt(n); t++)
                for (var e = 0; e < Math.sqrt(n); e++) {
                    var i = [2 * e, 2 * t, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, i);
                    Array.prototype.push.apply(simulateObject.spinDirections, [0, 0, 1])
                }
            simulateObject.createDataForWebGL(k);
            simulateObject.neighbors()
            this.energy();
            this.magnetization();
        },
        border_check: t => (Math.sqrt(n) + t) % Math.sqrt(n),
        espin(t) {
            var e = 0,
                i = 3 * t,
                s = 3 * t + 1,
                n = 3 * t + 2,
                a = 3 * simulateObject.spinNeighbor[4 * t],
                r = 3 * simulateObject.spinNeighbor[4 * t + 1],
                o = 3 * simulateObject.spinNeighbor[4 * t + 2],
                c = 3 * simulateObject.spinNeighbor[4 * t + 3];
            return e += simulateObject.spinDirections[i] * (simulateObject.spinDirections[a] + simulateObject.spinDirections[r] + simulateObject.spinDirections[o] + simulateObject.spinDirections[c]), e += simulateObject.spinDirections[s] * (simulateObject.spinDirections[a + 1] + simulateObject.spinDirections[r + 1] + simulateObject.spinDirections[o + 1] + simulateObject.spinDirections[c + 1]), -1 * (e += simulateObject.spinDirections[n] * (simulateObject.spinDirections[a + 2] + simulateObject.spinDirections[r + 2] + simulateObject.spinDirections[o + 2] + simulateObject.spinDirections[c + 2]))
        },
        energy() {
             var Esys = 0.;
            for (var num = 0; num < n; ++num) {
                Esys += simulateObject.espin(num)
            }
            Esys /= 2. * n;
            document.getElementById('display-energy').value = "E: " + Esys;
        },
        getRandomInclusive: (t, e) => (t = Math.ceil(t), e = Math.floor(e), Math.floor(Math.random() * (e - t + 1)) + t),
        getRandomIzing: () => 0 === Math.floor(2 * Math.random()) ? -1 : 1,
        randomspinIzing_create() {
            iteration += 1, simulateObject.spinPositions = [], simulateObject.spinDirections = [];
            for (var t = 0; t < Math.sqrt(n); t++)
                for (var e = 0; e < Math.sqrt(n); e++) {
                    var i = simulateObject.getRandomIzing(),
                        s = [2 * e, 2 * t, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, s);
                    var a = [0, 0, i];
                    Array.prototype.push.apply(simulateObject.spinDirections, a)
                }
            simulateObject.createDataForWebGL(k);
            this.energy();
            this.magnetization();
        },
        randomspin_create() {
            Math.sqrt(n);
            simulateObject.spinPositions = [], simulateObject.spinDirections = [];
            for (var t = 0; t < Math.sqrt(n); t++)
                for (var e = 0; e < Math.sqrt(n); e++) {
                    var i = [2 * e, 2 * t, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, i);
                    var s = simulateObject.getRandomInclusive(0, 360),
                        a = simulateObject.getRandomInclusive(0, 180),
                        r = s * Math.PI / 180,
                        o = a * Math.PI / 180,
                        c = [Math.sin(o) * Math.cos(r), Math.sin(o) * Math.sin(r), Math.cos(o)];
                    Array.prototype.push.apply(simulateObject.spinDirections, c)
                }
            simulateObject.createDataForWebGL(k);
            this.energy();
            this.magnetization();
        },
        skyrmion_create(){
            var t = .125 * Math.sqrt(n);
            simulateObject.spinPositions = [], simulateObject.spinDirections = [];
            for (var e = 0; e < Math.sqrt(n); e++)
                for (var i = 0; i < Math.sqrt(n); i++) {
                    var s = [2 * i, 2 * e, 0];
                    Array.prototype.push.apply(simulateObject.spinPositions, s);
                    var a = i - Math.sqrt(n) / 2,
                        r = e - Math.sqrt(n) / 2,
                        o = a * a + r * r + t * t,
                        c = [-t * a / o, -t * r / o, (a * a + r * r - t * t) / o];
                    Array.prototype.push.apply(simulateObject.spinDirections, c)
                }
            simulateObject.createDataForWebGL(k)
            this.energy();
            this.magnetization();
        },
        setK: coef => {
            simulateObject.k = coef;
        }
    };

    function parseToFile(spinPositions, spinDirections) {
        const spinsStrings = [];
        for (let index = 0; index < spinPositions.length; index += 3) {
            let spinPosition = spinPositions.slice(index, index + 3);
            let spinDirection = spinDirections.slice(index, index + 3);
    
            let pos = spinPosition.map(el => `${el} \t`);
            let dir = spinDirection.map(el => `${el} \t`);
            let result = "";
            pos.forEach(p => result += p);
            dir.forEach(p => result += p);
            if (index != spinPositions.length - 3)
                result += "\n";
            spinsStrings.push(result);
        }
        return spinsStrings;
    }

    function parseToArrays(t, e) {
        const i = t.split("\n");
        e.spinPositions = [], e.spinDirections = [];
        for (let t = i.indexOf("[parts]") + 1; t < i.length; t ++) {
            let s = i[t].split(/\t|  /), //делит по табуляции или двум пробелам
                n = s.slice(1, 4),
                a = s.slice(4, 7);
            for (let t = 0; t < 3; t++) {
                const i = parseFloat(n[t]),
                    s = parseFloat(a[t]);
                e.spinPositions.push(i), e.spinDirections.push(s)
            }
        }
    }

//Смена цвета
function updateColormap() {
    var colormap = $("option:selected", $('#select-colormap'))[0].value;
    webglspins.updateOptions({
    colormapImplementation: WebGLSpins.colormapImplementations[colormap]
    });
}

//Смена режима отображения
function updateRenderMode() {
    var renderMode = $("option:selected", $('#select-rendermode'))[0].value;
    var renderers = [WebGLSpins.renderers[renderMode]];
    var showCoordinateSystemWidget = true;
    if (showCoordinateSystemWidget) {
      renderers.push([WebGLSpins.renderers.COORDINATESYSTEM, [0, 0, 0.2, 0.2]]);
    }
    var showSphereWidget = true;
    if (showSphereWidget) {
      renderers.push([WebGLSpins.renderers.SPHERE, [0, 0, 0.2, 0.2]]);
    }
    webglspins.updateOptions({
      renderers: renderers
    });
  }

// Меню - бургер
function toggleMenu(){
    const button = document.getElementById('btn-menu');
    const menu = document.getElementById('list-menu');
    button.classList.toggle('active');
    menu.classList.toggle('active');
}

var flagRuller = 0;             //флаг для линейки
var flagSwapSpin = 0;           //флаг для поворота спина
var arrayForDistance = [];      //массив координат для линейки

//Обработчик события для линейки
function getDistance(){
    const button = document.getElementById('btn-ruler');
    button.classList.toggle('active');
    if(flagRuller == 2){
        document.getElementById('display-distance').value = simulateObject.vectLength([arrayForDistance[0],arrayForDistance[2]
            ,arrayForDistance[1],arrayForDistance[3],0 ,0]).toExponential(5);
        arrayForDistance = [];
        return;
    }
    document.getElementById('display-distance').value = "Точки не выбраны";
    flagRuller = 1;
}

//Обработчик события поворота спина
function swapSpin(){
    const button = document.getElementById('btn-swap');
    button.classList.toggle('active');
    if (flagSwapSpin == 0){
    flagSwapSpin = 1;
    }
    else if (flagSwapSpin == 1){
        flagSwapSpin = 0;
    }
}

//Рулетка, поворот спина, отображение координат
function getXY(x,y){
    var temp = [];
    if (flagRuller == 1){
        arrayForDistance.push(x,y);
        flagRuller ++;
    }
    else if (flagRuller == 2){
        arrayForDistance.push(x,y);
        getDistance();
        flagRuller = 0;
    }
    if (flagSwapSpin){
        temp = simulateObject.spinDirectionsWeb;
        temp2 = simulateObject.spinDirections;
        console.log("spinDirection size:" + temp.length);
        n = document.getElementById("initN").value;
        var numb = (n*(y-1) + x)*3-3;
        console.log("Size of grid: " + n + " use ind: " + numb.toFixed(3));
        temp [(n*(y-1) + x)*3-3] *= -1;
        temp [(n*(y-1) + x)*3-2] *= -1;
        temp [(n*(y-1) + x)*3-1] *= -1;
        temp2 [(n*(y-1) + x)*3-3] *= -1;
        temp2 [(n*(y-1) + x)*3-2] *= -1;
        temp2 [(n*(y-1) + x)*3-1] *= -1;
        webglspins.updateSpins(simulateObject.spinPositionsWeb, temp);
        simulateObject.energy();
        simulateObject.magnetization();
    }
    document.getElementById('display-xy').value = "X: " + x.toFixed(3) + " Y: " + y.toFixed(3);
}
